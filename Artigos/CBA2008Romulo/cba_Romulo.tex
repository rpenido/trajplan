\documentclass[conference,harvard,brazil,english]{sbatex}
\usepackage[latin1]{inputenc}
\usepackage{ae}
\usepackage{graphicx}
\usepackage{subfigure}


\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}
\clubpenalty=9999 \widowpenalty=9999 \hyphenpenalty=10000
%
% LaTeX2e class SBATeX
%
% Versão 1.0 alpha
%   Walter Fetter Lages
%   w.fetter@ieee.org
%
% Este arquivo cba_esq.tex é um esqueleto para geração do artigo para o CBA
%
% --------------------------------------------------
%
% Para compilar este exemplo use a seqüência de comandos:
%
%     latex cba_esq
%     bibtex cba_esq
%     latex cba_esq
%     latex cba_esq
%
% Para gerar um arquivo Postscript (.ps):
%
%     dvips -t a4 cba_esq
%
% Para gerar um arquivo Portable Document Format (.pdf):
%
%     dvips -Ppdf -t a4 cba_esq
%     ps2pdf -dMaxSubsetPct=100 -dSubsetFonts=true -dEmbedAllFonts=true -dCompatibilityLevel=1.2 -sPAPERSIZE=a4 cba_esq.ps
%
%\usepackage{psfig,epsfig}
%\usepackage{psfrag}
%\usepackage{graphics}

\begin{document}
% CABEÇALHO
\title{Programação off-line de robôs industriais a partir de imagens bidimensionais}
\author{Rômulo G. O. Penido}{romulo.penido@gmail.com}
\author[1]{Eduardo J. Lima II}{eduardo@demec.ufmg.br}
\address{Departamento de Engenharia Mecânica, Universidade Federal de Minas Gerais\\ Av. Antônio Carlos, 6627 - Pampulha  \\ Belo Horizonte, Minas Gerais, Brasil}

\twocolumn[
\maketitle
\selectlanguage{english}
\begin{abstract}
The use of robotic manipulators in manufacturing systems is in
constant grown due to its high flexibility, productivity and the
high quality achieved through its use. The search for flexible
manufacturing cells stimulates the development of robots and,
consequently, their programming methods. Increased use of robots
demand high qualified workers, able to master the technology
involved in their programming. Also, at each new task, the time
spent with the programming may slow down the production process.
In this article it is presented a methodology for trajectories
generation for robotic manipulators using computer vision
techniques, simplifying for the operator the task of programming
the robot. The task is drawn into an image file, representing the
trajectory to be done by the robot end-effector.
\end{abstract}
\keywords{Robotic manipulators, off-line programming, computer
vision.} \selectlanguage{brazil}
\begin{abstract}
A utilização de manipuladores robóticos em sistemas de manufatura
vem crescendo a cada dia devido à sua alta flexibilidade,
produtividade e ao alto padrão de qualidade obtido através desta
utilização. A busca de células de manufaturas flexíveis estimula o
desenvolvimento de robôs e, por conseqüência, sua forma de
programação. O aumento da utilização de robôs demanda uma mão de
obra qualificada, que seja capaz de dominar as tecnologias
envolvidas na sua programação, além do fato de que a cada nova
tarefa, o tempo gasto com a programação pode onerar o processo
produtivo. Neste artigo é apresentada uma metodologia para geração
de trajetórias para manipuladores robóticos utilizando técnicas de
visão computacional, simplificando bastante para o operador a
tarefa de programação do robô. A tarefa é desenhada em um arquivo
de imagem, representando a trajetória a ser realizada pelo
efetuador do robô.
\end{abstract}
\keywords{Manipuladores robóticos, programação \emph{off-line},
visão computacional} ]

\selectlanguage{brazil}

\section{Introdução}

Os primeiros robôs industriais começaram a ser fabricados e
utilizados com o intuito de se substituir o ser humano em tarefas
que ele não poderia realizar, seja por causa de suas próprias
limitações físicas, ou por envolverem condições desagradáveis ou
extremas. Além disso, a utilização de robôs industriais
possibilita uma melhora na qualidade do produto, uniformizando a
produção, eliminando perdas e refugos.

Com os avanços tecnológicos, a utilização de manipuladores robóticos
tem estado cada vez mais presente em todo o mundo. Isso se deve à
sua grande versatilidade visto que um robô pode ser reprogramado e
utilizado para as mais diversas tarefas dentro de um sistema de
manufatura.

O sucesso e eficiência na utilização de robôs em sistemas de
manufatura flexíveis desenvolvidos depende de interfaces
homem-máquina eficientes e habilidades do operador
\cite{Norberto}.

Atualmente, a programação do robô é feita através de um software
no qual é possível programar o robô diretamente no
chão-de-fábrica, ``ensinando'' ao robô os movimentos que devem ser
executados (programação \emph{on-line}), ou através de um
\emph{software} específico para a programação (programação
\emph{off-line}).

A programação \emph{on-line} de um robô, de um modo geral, pode
consumir muito tempo, evoluindo de modo desproporcional ao aumento
da complexidade das tarefas; conseqüentemente, quando o robô fica
fora da linha de produção, o tempo gasto na programação pode
prejudicar substancialmente a sua utilidade \cite{soldrobmanet}.
Nesses casos, métodos de programação \emph{off-line} tornam-se
atraentes, minimizando o tempo gasto com programação e
reprogramação.

\citeasnoun{Norberto} apresenta uma ferramenta de interface e
programação baseada em plataforma CAD e na utilização de uma
caneta digital para geração de programas para o robô. Dessa forma
o usuário desenha em um papel especial as trajetórias que pretende
executar no robô utilizando a caneta digital e o código do
programa é automaticamente gerado a partir dos pontos gerados
diretamente pela caneta.

No presente trabalho, a trajetória do manipulador é gerada a
partir de uma imagem bidimensional da tarefa, sem a necessidade da
caneta digital. Um algoritmo obtém os pontos de interesse na
imagem e gera as coordenadas para o programa na linguagem de
programação do robô previamente configurada.
%Através de métodos de visão computacional, apresentar uma
%metodologia para programação \emph{off-line} de manipuladores
%robóticos através da identificação de trajetórias em imagens
%bidimensionais geradas por computador.
Dessa forma o operador poderia, através de um programa simples de
edição de imagens, definir a trajetória do robô para determinada
operação sem a necessidade de conhecer a linguagem de programação
do robô. O programa é, então, gerado de forma \emph{off-line} e
posteriormente carregado no controlador do robô.

A seção \ref{sec:afin} apresenta uma revisão bibliográfica do
algoritmo de afinamento de imagens utilizado para extrair uma
figura com um pixel de largura a partir da imagem original. A
seção \ref{sec:deftraj} mostra o algoritmo desenvolvido para a
definição da trajetória pela ordenação dos pontos da imagem, e na
seção \ref{sec:progrb} é mostrada a geração do programa na
linguagem específica do controlador. Na seção \ref{sec:aplic} é
mostrado um exemplo de aplicação da metodologia apresentada e na
seção \ref{sec:concl} são apresentadas as conclusões e
perspectivas de trabalhos futuros e em andamento.

\section{Algoritmo de Afinamento}
\label{sec:afin}

O afinamento é uma operação aplicada a imagens binárias para
reduzi-las a uma cadeia simples com largura de um pixel,
preservando a sua conectividade e topologia. O objetivo do
afinamento é remover pixels redundantes na imagem de forma que
apenas os pixels essenciais sejam mantidos. Para este trabalho,
foi utilizado o algoritmo de afinamento de Zhang-Suen
\cite{Zhang}. O algoritmo de Zhang-Suen é um algoritmo de
afinamento paralelo. No afinamento paralelo, os pixels são
examinados para exclusão baseando-se apenas na iteração anterior.
Dessa forma, a imagem pode ser dividida em partes menores e o
processamento destas partes pode ser feito de forma independente
(o que acarretaria um ganho de desempenho em um computador com
mais de um processador).

O algoritmo de Zhang-Suen avalia cada ponto da imagem e, através
da análise da sua vizinhança (um quadrado 3x3 em volta do pixel,
como mostrado na Figura \ref{fig:EsquemaZhang}), define se este
pixel pode ou não ser removido da imagem, sem afetar sua
conectividade.

\begin{figure}[htb]
    \center
    \begin{tabular}{|c|c|c|}
        \hline
        $P_9$ & $P_2$ & $P_3$  \\
        \hline
        $P_8$ & $P$ & $P_4$ \\
        \hline
        $P_7$ & $P_6$ & $P_5$ \\
        \hline
    \end{tabular}
    \caption{Numeração de pixels utilizada no algoritmo.}
    \label{fig:EsquemaZhang}
\end{figure}

Esse algoritmo é composto por duas subiterações. Na primeira, o
ponto P é excluído se satisfaz as seguintes condições:
\begin{description}
    \item [(a)] $ 2 <= NN(P) <= 6 $,
    \item [(b)] $ CRN(P) = 2 $,
    \item [(c)] $ P2 * P4 * P6 = 0 $,
    \item [(d)] $ P4 * P6 * P8 = 0 $,
\end{description}
onde $NN(P)$ é o número de pixels vizinhos de $P$ na cor preta e
$CRN(P)$ é o número de transições de branco para preto dos pixels
vizinhos ao longo de uma rotação em torno de $P$. $P2$ a $P9$
assumem valor 1 quando o pixel é preto e 0 quando é branco. Na
segunda iteração, as duas últimas condições são substituídas por
suas rotações de 180º:
\begin{description}
    \item [(c')] $ P2 * P6 * P8 = 0 $
    \item [(d')] $ P2 * P4 * P8 = 0 $
\end{description}

Assim, o primeiro ciclo exclui pixels nas bordas sul, leste e
noroeste e o segundo exclui pixels nas posições opostas ao
primeiro. Um dos problemas deste algoritmo é que ele não garante
que o esqueleto gerado possua apenas um pixel de largura. Para
resolver esse problema, foi utilizada a fórmula de Holt
\cite{Holt} para remoção em escada. O processo de remoção em
escada explora a seguinte propriedade: metade dos pixels que
apresentam uma forma semelhante a uma escada pode ser removida sem
afetar o formato ou a conectividade do objeto. O algoritmo se
baseia em varrer toda a imagem e remover pixels da posição central
que se encaixem em uma das máscaras mostradas na Figura
\ref{fig:mascaras}, em que $x$ pode assumir qualquer valor, 0 ou
1.

\begin{figure}[htb]
    \begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        0 & 1 & $x$ \\
        \hline
        1 & 1 & $x$ \\
        \hline
        $x$ & $x$ & 0 \\
        \hline
    \end{tabular}
    \hspace{20pt}
    \begin{tabular}{|c|c|c|}
        \hline
        $x$ & 1 & 0 \\
        \hline
        $x$ & 1 & 1 \\
        \hline
        0 & $x$ & $x$ \\
        \hline
    \end{tabular}
    \\ \vspace{10pt}
    \begin{tabular}{|c|c|c|}
        \hline
        0 & $x$ & $x$ \\
        \hline
        $x$ & 1 & 1 \\
        \hline
        $x$ & 1 & 0 \\
        \hline
    \end{tabular}
    \hspace{20pt}
    \begin{tabular}{|c|c|c|}
        \hline
        $x$ & $x$ & 0 \\
        \hline
        1 & 1 & $x$ \\
        \hline
        0 & 1 & $x$ \\
        \hline
    \end{tabular}
\end{center}
    \caption{Máscaras utilizadas para remoção de pixels pela fórmula de Holt.}
    \label{fig:mascaras}
\end{figure}

\section{Definição da Trajetória}
\label{sec:deftraj}

Uma vez que a linha de trajetória passou pelo algoritmo de
afinamento, é necessário ordenar os pontos e gerar a trajetória
para o robô. O primeiro passo é definir qual será o ponto inicial.

O ponto inicial será o ponto que possuir número de vizinhos igual
a 1 e possuir a cor verde (escolhida arbitrariamente). A cor
diferente foi utilizada já que a trajetória desenhada possui duas
extremidades, e o pixel de cada extremidade atende ao critério de
possuir apenas um vizinho.

Definido o ponto inicial, é necessário ordenar todos os outros
pontos para formar a trajetória. Para esta ordenação, é criada uma
matriz de direções [x,y] equivalente à imagem e para cada ponto
pertencente à trajetória é associada a informação referente à sua
conectividade, ou seja, as direções em torno do pixel que possuem
pixels pertencentes à trajetória, como mostrado na Figura
\ref{fig:MatDir}.

\begin{figure}[htb]
    \centerline{
        \subfigure[]{\includegraphics[width=100pt]{images/MatDir1.eps}
        \label{fig:MatDir-a}}
        \hfil
        \subfigure[]{\includegraphics[width=100pt]{images/MatDir2.eps}
        \label{fig:MatDir-b}}
    }
    \caption{Exemplo de figura representando uma trajetória com cruzamento: pontos da trajetória (a) e direções
    dos pontos vizinhos (b).}
    \label{fig:MatDir}
\end{figure}

Após criada a matriz de direções, a partir do ponto inicial da
trajetória,  os pontos são ordenados. O algoritmo se baseia em
percorrer os pontos adjacentes até que não existam mais pontos a
serem percorridos. Caso exista mais de um ponto adjacente a um
mesmo pixel, será escolhido aquele que cause menor modificação na
direção e sentido do caminho percorrido pelo robô. Caso dois
pontos causem a mesma alteração no movimento, serão verificadas
recursivamente as direções dos pontos anteriores. Caso o empate
persista, é escolhido um ponto de acordo com a ordem N, NE, E, SE,
S, SW, W, NW (mesma ordem de numeração dos pontos no algoritmo de
Zhang-Suen).

Caso existam vários pontos alinhados, os pontos intermediários
serão removidos. Assim, o volume de pontos gerado para o robô será
reduzido significativamente, sem modificar a trajetória.

A Figura \ref{fig:ExOrd} mostra a aplicação do algoritmo passo a
passo para uma trajetória que possui um cruzamento.

\begin{figure}[htb]
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord1.eps}
        \label{fig:ExOrd-a}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord2.eps}
        \label{fig:ExOrd-b}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord3.eps}
        \label{fig:ExOrd-c}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord4.eps}
        \label{fig:ExOrd-d}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord5.eps}
        \label{fig:ExOrd-e}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord6.eps}
        \label{fig:ExOrd-f}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord7.eps}
        \label{fig:ExOrd-g}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord8.eps}
        \label{fig:ExOrd-h}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord9.eps}
        \label{fig:ExOrd-i}}
    }
    \caption{Ordenamento dos pontos de acordo com a direção da trajetória.}
    \label{fig:ExOrd}
\end{figure}

O primeiro passo do algoritmo é definir o ponto inicial da
trajetória. Na Figura \ref{fig:ExOrd-a} é mostrado o ponto inicial
em verde, onde a primeira iteração é realizada. Nesse momento, só
há uma direção possível para ser seguida, logo, o próximo ponto da
trajetória deve ser o ponto na direção SE.

Neste ponto, existem três direções possíveis:  NE, E e SW, como
mostra a Figura \ref{fig:ExOrd-b}. A direção E será escolhida pois é
a que causa uma menor variação na direção de movimento do robô.

Logo após, o ponto escolhido é verificado. A partir dele, três
direções possíveis podem ser escolhidas: N, NE e SE. Visto que o
robô estará se deslocando na direção E (por causa do movimento
anterior), duas das possibilidades possíveis proporcionam a mesma
mudança de direção em relação ao movimento anterior: NE e SE.
Ambas ocasionam uma mudança de direção menor que se o robô fosse
para a direção restante (N). Como o critério da direção anterior
não é suficiente para escolher qual ponto seguir, a direção do
passo imediatamente anterior a esta será avaliada. Como esta
direção anterior é  SE (mostrado na Figura \ref{fig:ExOrd-b}), o
caminho a escolhido é seguir a direção SE, como mostrado na Figura
\ref{fig:ExOrd-c}.

As próximas escolhas são feitas de forma simples, visto que só
existe uma direção a ser seguida, como mostrado na Figura
\ref{fig:ExOrd-d} e Figura \ref{fig:ExOrd-e}. Ao chegar novamente no
ponto indicado pela Figura \ref{fig:ExOrd-f}, o algoritmo
selecionará a direção NE, pois é a única deste ponto que ainda não
foi visitada.

No próximo passo, mostrado na Figura \ref{fig:ExOrd-g}, existem
duas possibilidades de direções, S e E, sendo que a direção E leva
a uma menor variação da direção anterior.

No último passo a direção escolhida é NE como mostrado na
\ref{fig:ExOrd-h}. O algoritmo continua até encontrar um ponto que
não possui mais nenhuma direção disponível a ser seguida. A
trajetória encontrada para esta configuração é exibida na
\ref{fig:ExOrd-i}.


Os pontos escolhidos são armazenados na forma de uma lista
encadeada. Além das coordenadas [x,y], a cor do ponto também é
armazenada para futuramente definir os parâmetros da trajetória
(por exemplo, velocidade de movimentação, parâmetros de soldagem
etc.).

\section{Geração do programa para o robô}
\label{sec:progrb}

Depois de montada a lista com informações da trajetória e de
parâmetros de utilização, é necessário gerar o programa na
linguagem do robô para executar essas tarefas. O arquivo é gerado
baseando-se em um modelo de acordo com a linguagem do robô. A
utilização do modelo permite que o usuário possa inserir
informações específicas ou programar alguma tarefa antes da
execução da trajetória. A programação da trajetória é inserida no
código em uma posição definida no modelo entre as marcações
\begin{ttfamily};\#MainSection\#Begin\#\end{ttfamily} e
\begin{ttfamily};\#MainSection\#End\#\end{ttfamily}. A
Figura \ref{fig:TemplateModProg} mostra um exemplo de programa
gerado na linguagem KRL para o controlador KRC-2, da KUKA Roboter.

\begin{figure}[htb]


    \framebox{
    \begin{minipage}{200pt}
    \ttfamily
    \footnotesize
    DEF \#\$FileName\#( ) \\
    INI \\
    \\
    BAS(\#FRAMES) \\
    BAS(\#VEL\_PTP,20) \\
    PTP XHOME \\
    \\
    ;\#MainSection\#Begin\# \\
    LIN \{x 1, y 1,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 2, y 2,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 3, y 2,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 4, y 3,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 3, y 4,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 2, y 4,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 1, y 3,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 2, y 2,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 3, y 1,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 4, y 1,z 0,a 0,b 0,c 0\} C\_VEL \\
    LIN \{x 5, y 0,z 0,a 0,b 0,c 0\} C\_VEL \\
    ;\#MainSection\#End\# \\
    \\
    PTP XHOME \\
    END
    \end{minipage}
    }
    \caption{Modelo de programa para KRC-2.}
    \label{fig:TemplateModProg}
\end{figure}

Além das coordenadas dos pontos, outras informações podem ser
dinamicamente adicionadas neste arquivo de acordo com a cor dos
pixels definidos em cada parte da trajetória.

\section{Aplicação da metodologia}
\label{sec:aplic}

A metodologia apresentada foi aplicada na geração de um programa
para o manipulador robótico KUKA modelo KR-6 com controlador
KRC-2.

Para o teste do algoritmo foi utilizada uma imagem de 160x120
pixels com uma trajetória que possuía um cruzamento. A Figura
\ref{fig:Resultados} mostra passo a passo a execução dos
algoritmos de processamento da imagem.

\begin{figure}[htb]
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/origin.eps}}
        \label{fig:Result-a}}
        \hfil
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/thin1.eps}}
        \label{fig:Result-b}}
    }
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/thin2.eps}}
        \label{fig:Result-c}}
        \hfil
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/thinResult.eps}}
        \label{fig:Result-d}}
    }
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/staircaseremov.eps}}
        \label{fig:Result-e}}
        \hfil
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/startpoint.eps}}
        \label{fig:Result-f}}
    }
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/result.eps}}
        \label{fig:Result-g}}
    }
    \caption{Etapas do processamento de uma imagem.}
    \label{fig:Resultados}
\end{figure}

A Figura \ref{fig:Result-a} mostra a imagem utilizada para testar
a metodologia apresentada neste artigo. O primeiro passo é, sobre
esta imagem, aplicar o algoritmo de afinamento.

Na Figura \ref{fig:Result-b} são mostrados na cor vermelha os
pixels que serão removidos pelo critério de seleção feito na
primeira subiteração e a Figura \ref{fig:Result-c} mostra em azul
os pixels que serão removidos na segunda subiteração.

A Figura \ref{fig:Result-d} apresenta o resultado final do
processo de afinamento. Uma vez que a imagem já foi afinada, é
aplicado o método de remoção de escadas. Os pixels redundantes são
destacados na Figura \ref{fig:Result-e} na cor vermelha.

Após todos os pixels desnecessários serem removidos, o ponto
inicial da trajetória é identificado, como mostra a Figura
\ref{fig:Result-f}. A Figura \ref{fig:Result-g} mostra os pixels
selecionados durante a ordenação, que caracterizam a trajetória.

Como todas as informações relativas à trajetória são independentes
do modelo de robô escolhido, com poucas alterações pode ser
adaptado para qualquer outro modelo ou fabricante.

\section{Conclusões}
\label{sec:concl}

Foi apresentada uma metodologia para geração de trajetórias para
robôs industriais a partir de imagens bidimensionais geradas
artificialmente. O programa se mostrou eficiente, sendo capaz de
tratar inclusive trajetórias que possuam cruzamentos, escolhendo a
direção e sentido de movimento mais apropriados.

Atualmente, encontra-se em desenvolvimento uma metodologia para
definição automática do sistema de coordenadas e escala do desenho
a partir de eixos representados na própria imagem. Além disso,
técnicas de tratamento de imagens estão sendo aplicadas para
possibilitar a utilização de fotografias no próprio espaço de
trabalho do robô.

\section*{Agradecimentos}
Os autores agradecem ao PIBIC/CNPq pelo apoio financeiro e à KUKA
Roboter pela disponibilização do equipamento para realização dos
testes.

% BIBLIOGRAFIA
\bibliography{bibliRomulo}
\end{document}


% ##################### TEXTO REMOVIDO #####################
Em determinados casos de linhas com cruzamento, os algoritmos para
detecção da trajetória falharam. Isso se deve ao fato do algoritmo
de afinamento ter alterado ligeiramente a topologia da região do
cruzamento de linhas, como mostrado na Figura
\ref{fig:Cruzamento}.

\begin{figure}[htb]
   \centerline{
       \subfigure[XXX 1ª XXX]{\fbox{\includegraphics[width=100pt]{images/cross1.eps}}
       \label{fig:XXX}}
       \hfil
       \subfigure[XXX 2ª XXX]{\fbox{\includegraphics[width=100pt]{images/cross2.eps}}
       \label{fig:XXXX}}
   }
   \centerline{
       \subfigure[XXX 2ª XXX]{\fbox{\includegraphics[width=100pt]{images/cross3.eps}}
       \label{fig:XXXXX}}
   }

   \caption{\it ??????????}
    \label{fig:Cruzamento}
\end{figure}
