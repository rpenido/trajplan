\documentclass[conference,harvard,brazil,english]{sbatex}
\usepackage[latin1]{inputenc}
\usepackage{ae}
\usepackage{colortbl}
\usepackage{graphicx}
\usepackage{subfigure}


\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}
\clubpenalty=9999 \widowpenalty=9999 \hyphenpenalty=9999
%
% LaTeX2e class SBATeX
%
% Versão 1.0 alpha
%   Walter Fetter Lages
%   w.fetter@ieee.org
%
% Este arquivo cba_esq.tex é um esqueleto para geração do artigo para o CBA
%
% --------------------------------------------------
%
% Para compilar este exemplo use a seqüência de comandos:
%
%     latex cba_esq
%     bibtex cba_esq
%     latex cba_esq
%     latex cba_esq
%
% Para gerar um arquivo Postscript (.ps):
%
%     dvips -t a4 cba_esq
%
% Para gerar um arquivo Portable Document Format (.pdf):
%
%     dvips -Ppdf -t a4 cba_esq
%     ps2pdf -dMaxSubsetPct=100 -dSubsetFonts=true -dEmbedAllFonts=true -dCompatibilityLevel=1.2 -sPAPERSIZE=a4 cba_esq.ps
%
%\usepackage{psfig,epsfig}
%\usepackage{psfrag}
%\usepackage{graphics}
\begin{document}
% CABEÇALHO
\title{Programação off-line de robôs industriais a partir de imagens bidimensionais}
\author{Rômulo G. O. Penido}{romulo.penido@gmail.com}
\author[1]{Eduardo J. Lima II}{eduardo@demec.ufmg.br}
\address{Departamento de Engenharia Mecânica, Universidade Federal de Minas Gerais\\ Av. Antônio Carlos, 6627 - Pampulha  \\ Belo Horizonte, Minas Gerais, Brasil}

\twocolumn[
\maketitle
\selectlanguage{english}
\begin{abstract}
    Abstract
\end{abstract}
\keywords{Enter Keywords Here.}
\selectlanguage{brazil}
\begin{abstract}
    Resumo
\end{abstract}
\keywords{????????????????} ]

\selectlanguage{brazil}

\section{Introdução}

% Falar das dificuldades de um operador de programar o robô

A programação \emph{on-line} de um robô, de um modo geral, pode
consumir muito tempo, evoluindo de modo desproporcional ao aumento
da complexidade das tarefas; conseqüentemente, quando o robô fica
fora da linha de produção, o tempo gasto na programação pode
prejudicar substancialmente a sua utilidade \cite{soldrobmanet}.
Nesses casos, métodos de programação \emph{off-line} tornam-se
atraentes, minimizando o tempo gasto com programação e
reprogramação.

\citeasnoun{Norberto} mostra uma metodologia para gerar
trajetórias a partir de um desenho feito utilizando uma caneta
digital. .......

O presente trabalho apresenta uma abordagem diferente ao problema
de planejamento de trajetórias. O objetivo é, através de métodos
de visão computacional, apresentar uma metodologia para
identificação de trajetórias em imagens bidimensionais geradas por
computador. Desta forma o operador poderia, através de um programa
simples de edição de imagens, definir a trajetória do robô para
determinada operação sem a necessidade de conhecer a linguagem de
programação do robô. A utilização

\section{Algoritmo de Afinamento}
O afinamento é uma operação aplicada a imagens binárias para
reduzi-las a uma cadeia simples com largura de um pixel,
preservando a sua conectividade e topologia. O objetivo do
afinamento é remover pixels redundantes na imagem de forma que
apenas os pixels essenciais sejam mantidos.
Para este trabalho, foi utilizado o algoritmo de afinamento de
Zhang-Suen \cite{Zhang}. O algoritmo de Zhang-Suen é um algoritmo
de afinamento paralelo. No afinamento paralelo, os pixels são
examinados para exclusão baseando-se apenas na iteração anterior.
Desta forma, a imagem pode ser dividida em partes menores e o
processamento destas partes pode ser feito de forma independente
(o que acarretaria um ganho de desempenho em um computador com
mais de um processador).



O algoritmo de Zhang-Suen avalia cada ponto da imagem e, através
da análise da sua vizinhança (um quadrado 3x3 em volta do pixel,
como mostrado na Figura \ref{fig:EsquemaZhang}), define se este
pixel pode ou não ser removido da imagem, sem afetar sua
conectividade.

\begin{figure}[htb]
    \center
    \begin{tabular}{|c|c|c|}
        \hline
        $P_9$ & $P_2$ & $P_3$  \\
        \hline
        $P_8$ & $P$ & $P_4$ \\
        \hline
        $P_7$ & $P_6$ & $P_5$ \\
        \hline
    \end{tabular}
    \caption{Numeração de pixels utilizada no algoritmo.}
    \label{fig:EsquemaZhang}
\end{figure}

Este algoritmo é composto por duas subiterações. Na primeira, o
ponto P é excluído se satisfaz as seguintes condições:

\begin{description}
    \item [(a)] $ 2 <= NN(P) <= 6 $,
    \item [(b)] $ CRN(P) = 2 $,
    \item [(c)] $ P2 * P4 * P6 = 0 $,
    \item [(d)] $ P4 * P6 * P8 = 0 $,
\end{description}
onde NN(P) é o número de pixels vizinhos de P na cor preta e
CRN(P) é o número de transições de branco para preto dos pixels
vizinhos ao longo de uma rotação em torno de P. P2 a P9 assumem
valor 1 quando o pixel é preto e 0 quando é branco. Na segunda
iteração, as duas últimas condições são substituídas por suas
rotações de 180º.

\begin{description}
    \item [(c')] $ P2 * P6 * P8 = 0 $
    \item [(d')] $ P2 * P4 * P8 = 0 $
\end{description}

Assim, o primeiro ciclo exclui pixels nas bordas sul, leste e
noroeste e o segundo exclui pixels nas posições opostas ao
primeiro. Um dos problemas deste algoritmo é que ele não garante
que o esqueleto gerado possua apenas um pixel de largura. Para
resolver esse problema, foi utilizada a fórmula de Holt
\cite{Holt} para remoção em escada. O processo de remoção em
escada explora a seguinte propriedade: metade dos pixels que
apresentam uma forma semelhante a uma escada pode ser removida sem
afetar o formato ou a conectividade do objeto. O algoritmo se
baseia em varrer toda a imagem e remover pixels da posição central
que se encaixem em uma das máscaras:

\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        0 & 1 & $x$ \\
        \hline
        1 & 1 & $x$ \\
        \hline
        $x$ & $x$ & 0 \\
        \hline
    \end{tabular}
    \hspace{20pt}
    \begin{tabular}{|c|c|c|}
        \hline
        $x$ & 1 & 0 \\
        \hline
        $x$ & 1 & 1 \\
        \hline
        0 & $x$ & $x$ \\
        \hline
    \end{tabular}
    \\ \vspace{10pt}
    \begin{tabular}{|c|c|c|}
        \hline
        0 & $x$ & $x$ \\
        \hline
        $x$ & 1 & 1 \\
        \hline
        $x$ & 1 & 0 \\
        \hline
    \end{tabular}
    \hspace{20pt}
    \begin{tabular}{|c|c|c|}
        \hline
        $x$ & $x$ & 0 \\
        \hline
        1 & 1 & $x$ \\
        \hline
        0 & 1 & $x$ \\
        \hline
    \end{tabular}
\end{center}
em que $x$ pode assumir qualquer valor, 0 ou 1.

\section{Definição da Trajetória}
Uma vez que a linha de trajetória passou pelo algoritmo de
afinação, é necessário ordenar os pontos e gerar a trajetória para
o robô. O primeiro passo é definir qual será o ponto inicial.

O ponto inicial será o ponto que possuir número de vizinhos igual
a 1 e possuir a cor verde (escolhida arbitrariamente). A cor
diferente foi utilizada já que a trajetória desenhada possui duas
extremidades, e o pixel de cada extremidade atende ao critério de
possuir apenas um vizinho.

Definido o ponto inicial, é necessário ordenar todos os outros
pontos para formar a trajetória. Para esta ordenação, é criada uma
matriz de direções [x,y] equivalente à imagem e para cada ponto
pertencente à trajetória é associada a informação referente à sua
conectividade, ou seja, as direções em torno do pixel que possuem
pixels pertencentes à trajetória, como mostrado na Figura
\ref{fig:MatDir}.

\begin{figure}[htb]
    \centerline{
        \subfigure[]{\includegraphics[width=100pt]{images/MatDir1.eps}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\includegraphics[width=100pt]{images/MatDir2.eps}
        \label{fig:XXXX}}
    }
    \caption{Exemplo de figura representando uma trajetória com cruzamento: pontos da trajetória (a) e direções
    dos pontos vizinhos (b).}
    \label{fig:MatDir}
\end{figure}

Após criada a matriz de direções, a partir do ponto inicial da
trajetória,  os pontos são ordenados. O algoritmo se baseia em
percorrer os pontos adjacentes até que não existam mais pontos a
serem percorridos. Caso exista mais de um ponto adjacente a um
mesmo pixel, será escolhido aquele que cause menor modificação na
direção e sentido do caminho percorrido pelo robô. Caso dois
pontos causem a mesma alteração no movimento, serão verificadas
recursivamente as direções dos pontos anteriores. Caso o empate
persista, é escolhido um ponto de acordo com a ordem N, NE, E, SE,
S, SW, W, NW (mesma ordem de numeração dos pontos no algoritmo de
Zhang-Suen).

A Figura \ref{fig:ExOrd} mostra a aplicação do algoritmo passo a
passo para uma trajetória que possui um cruzamento.



\begin{figure}[htb]
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord1.eps}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord2.eps}
        \label{fig:XXXX}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord3.eps}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord4.eps}
        \label{fig:XXXX}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord5.eps}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord6.eps}
        \label{fig:XXXX}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord7.eps}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\includegraphics[width=90pt]{images/Ord8.eps}
        \label{fig:XXXX}}
    }
    \centerline{
        \subfigure[]{\includegraphics[width=90pt]{images/Ord9.eps}
        \label{fig:XXX}}
    }
    \caption{Ordenamento dos pontos de acordo com a direção da trajetória.}
    \label{fig:ExOrd}
\end{figure}

EXPLICAR A FIGURA


Os pontos escolhidos são armazenados na forma de uma lista
encadeada. Além das coordenadas [x,y], a cor do ponto também é
armazenada para futuramente definir os parâmetros da trajetória
(por exemplo, velocidade de movimentação, parâmetros de soldagem
etc.).

\section{Geração do programa para o robô}
Depois de montada a lista com informações da trajetória e de
parâmetros de utilização, é necessário gerar o programa na
linguagem do robô para executar estas tarefas. O arquivo é gerado
baseando-se em um modelo de acordo com a linguagem do robô. A
utilização do modelo permite que o usuário possa inserir
informações específicas ou programar alguma tarefa antes da
execução da trajetória. A programação da trajetória é inserida no
código em uma posição definida no modelo entre as marcações
\begin{ttfamily}; \#MainSection\#Begin\#\end{ttfamily} e
\begin{ttfamily}; \#MainSection\#End\#\end{ttfamily}, como mostrado na
Figura \ref{fig:TemplateKUKA}.

\begin{figure}[htb]
%    \sffamily
   {\ttfamily
   {\footnotesize
    DEF \#\$FileName\#( ) \\
    INI \\
    \\
    BAS(\#FRAMES) \\
    BAS(\#VEL\_PTP,20) \\
    PTP XHOME \\
    \\
    ; \#MainSection\#Begin\# \\
    ; \#MainSection\#End\# \\
    \\
    PTP XHOME \\
    END}}
    \caption{Modelo de programa para KRC-2.}
    \label{fig:TemplateKUKA}
\end{figure}

COLOCAR PROGRAMA PARA OS PONTOS DA FIGURA 3




\section{Aplicação da metodologia}
A metodologia apresentada foi aplicada na geração de um programa
para o manipulador robótico KUKA modelo KR-6 com controlador
KRC-2.

Para o teste do algoritmo foi utilizada uma imagem de 160x120
pixels com uma trajetória que possuía um cruzamento. A Figura
\ref{fig:Resultados} mostra passo a passo a execução dos
algoritmos de processamento da imagem.

\begin{figure}[htb]
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/origin.eps}}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/thin1.eps}}
        \label{fig:XXXX}}
    }
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/thin2.eps}}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/thinResult.eps}}
        \label{fig:XXXX}}
    }
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/staircaseremov.eps}}
        \label{fig:XXX}}
        \hfil
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/startpoint.eps}}
        \label{fig:XXXX}}
    }
    \centerline{
        \subfigure[]{\fbox{\includegraphics[width=100pt]{images/result.eps}}
        \label{fig:XXX}}
    }
    \caption{Etapas do processamento de uma imagem.}
    \label{fig:Resultados}
\end{figure}

FALAR AQUI DAS ETAPAS

COLOCAR EM DETALHE O CRUZAMENTO

%Em determinados casos de linhas com cruzamento, os algoritmos para
%detecção da trajetória falharam. Isso se deve ao fato do algoritmo
%de afinamento ter alterado ligeiramente a topologia da região do
%cruzamento de linhas, como mostrado na Figura
%\ref{fig:Cruzamento}.

%\begin{figure}[htb]
%   \centerline{
%       \subfigure[XXX 1ª XXX]{\fbox{\includegraphics[width=100pt]{images/cross1.eps}}
%       \label{fig:XXX}}
%       \hfil
%       \subfigure[XXX 2ª XXX]{\fbox{\includegraphics[width=100pt]{images/cross2.eps}}
%       \label{fig:XXXX}}
%   }
%   \centerline{
%       \subfigure[XXX 2ª XXX]{\fbox{\includegraphics[width=100pt]{images/cross3.eps}}
%       \label{fig:XXXXX}}
%   }
%
%   \caption{\it ??????????}
%    \label{fig:Cruzamento}
%\end{figure}

Como todas as informações relativas à trajetória são independentes
do modelo de robô escolhido, com poucas alterações pode ser
adaptado para qualquer outro modelo ou fabricante.

\section{Conclusões}
Foi apresentada uma metodologia para geração de trajetórias para
robôs industriais a partir de imagens bidimensionais geradas
artificialmente. O programa se mostrou eficiente, sendo capaz de
tratar inclusive trajetórias que possuam cruzamentos, escolhendo a
direção e sentido de movimento mais apropriados.

Atualmente, encontra-se em desenvolvimento uma metodologia para
definição automática do sistema de coordenadas e escala do desenho
a partir de eixos representados na própria imagem. Além disso,
técnicas de tratamento de imagens estão sendo estudadas para ser
possível a utilização de fotografias no próprio espaço de trabalho
do robô.

\section*{Agradecimentos}
Os autores agradecem ao PIBIC/CNPq pelo apoio financeiro e à KUKA
Roboter pela disponibilização do equipamento para realização dos
testes.

% BIBLIOGRAFIA
\bibliography{bibliRomulo}
\end{document}
