\documentclass[conference,harvard,brazil,english]{sbatex}
\usepackage[latin1]{inputenc}
\usepackage{ae}
\usepackage{colortbl}
%
% LaTeX2e class SBATeX
%
% Versão 1.0 alpha
%   Walter Fetter Lages
%   w.fetter@ieee.org
%
% Este arquivo cba_esq.tex é um esqueleto para geração do artigo para o CBA
%
% --------------------------------------------------
%
% Para compilar este exemplo use a seqüência de comandos:
%
%     latex cba_esq
%     bibtex cba_esq
%     latex cba_esq
%     latex cba_esq
%
% Para gerar um arquivo Postscript (.ps):
%
%     dvips -t a4 cba_esq
%
% Para gerar um arquivo Portable Document Format (.pdf):
%
%     dvips -Ppdf -t a4 cba_esq
%     ps2pdf -dMaxSubsetPct=100 -dSubsetFonts=true -dEmbedAllFonts=true -dCompatibilityLevel=1.2 -sPAPERSIZE=a4 cba_esq.ps
%
%\usepackage{psfig,epsfig}
%\usepackage{psfrag}
%\usepackage{graphics}


\begin{document}

% CABEÇALHO

\title{Título do Artigo}

\author{Rômulo G. O. Penido}{romulo.penido@gmail.com}
\author[1]{Eduardo J. Lima II}{eduardo@demec.ufmg.br}
\address{Departamento de Engenharia Mecânica, Universidade Federal de Minas Gerais\\ Av. Antônio Carlos, 6627 - Pampulha  \\ Belo Horizonte, Minas Gerais, Brasil}



\twocolumn[

\maketitle

\selectlanguage{english}
\begin{abstract}
    Enter abstract here.
\end{abstract}

\keywords{Enter Keywords Here.}

\selectlanguage{brazil}
\begin{abstract}
    Coloque o resumo aqui.
\end{abstract}

\keywords{????????????????}
]



\selectlanguage{brazil}


% CONTRIBUIÇÃO

\section{Introdução}

Introdução

\section{Algoritmo de Afinamento}

O afinamento é uma operação aplicada a imagens binárias para
reduzi-las a uma cadeia simples com largura de um pixel,
preservando a sua conectividade e topologia. O objetivo do
afinamento é remover pixels redundantes na imagem de forma que
apenas os pixels essenciais sejam mantidos.

Para este trabalho, foi utilizado o algoritmo de afinamento de
Zhang-Suen \cite{Zhang}. O algoritmo de Zhang-Suen é um algoritmo
de afinamento paralelo. No afinamento paralelo, os pixels são
examinados para exclusão baseando-se apenas na iteração anterior.
Desta forma, a imagem pode ser dividida em partes menores e o
processamento destas partes pode ser feito de forma independente
(o que acarretaria um ganho de desempenho em um computador com
mais de um processador).

\begin{figure}[htb]
    \center
    \begin{tabular}{|c|c|c|}
        \hline
        $P_9$ & $P_2$ & $P_3$  \\
        \hline
        $P_8$ & $P$ & $P_4$ \\
        \hline
        $P_7$ & $P_6$ & $P_5$ \\
        \hline
    \end{tabular}
    \caption{???}
    \label{fig:EsquemaZhang}
\end{figure}

O algoritmo de Zhang-Suen avalia cada ponto da imagem e, através
da análise da sua vizinhança (um quadrado 3x3 em volta do pixel,
como mostrado na Figura \ref{fig:EsquemaZhang}), define se este
pixel pode ou não ser removido da imagem, sem afetar sua
conectividade. Este algoritmo é composto por duas subiterações. Na
primeira, o ponto P é excluído se satisfaz as seguintes condições:

\begin{description}
    \item [(a)] $ 2 <= NN(P) <= 6 $
    \item [(b)] $ CRN(P) = 2 $
    \item [(c)] $ P2 * P4 * P6 = 0 $
    \item [(d)] $ P4 * P6 * P8 = 0 $
\end{description}

Onde NN(P) é o número de pixels vizinhos de P na cor preta e
CRN(P) é o número de transições de branco para preto dos pixels
vizinhos ao longo de uma rotação em torno de P. P2 a P9 assumem
valor 1 quando o pixel é preto e 0 quando é branco.

Na segunda iteração, as duas últimas condições são substituídas
por suas rotações de 180º.

\begin{description}
    \item [(c')] $ P2 * P6 * P8 = 0 $
    \item [(d')] $ P2 * P4 * P8 = 0 $
\end{description}

Assim, o primeiro ciclo exclui pixels nas bordas sul, leste e
noroeste e o segundo exclui pixels nas posições opostas ao
primeiro. Um dos problemas deste algoritmo é que ele não garante
que o esqueleto gerado possua apenas um pixel de largura.

Para resolver esse problema, foi utilizada a fórmula de Holt
\cite{Holt} para remoção em escada. O processo de remoção em
escada explora a seguinte propriedade: metade dos pixels que
apresentam uma forma semelhante a uma escada pode ser removida sem
afetar o formato ou a conectividade do objeto. O algoritmo se
baseia em varrer toda a imagem e remover pixels que se encaixam em
uma das máscaras:

\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        0 & 1 & $x$ \\
        \hline
        1 & 1 & $x$ \\
        \hline
        $x$ & $x$ & 0 \\
        \hline
    \end{tabular}
    \hspace{20pt}
    \begin{tabular}{|c|c|c|}
        \hline
        $x$ & 1 & 0 \\
        \hline
        $x$ & 1 & 1 \\
        \hline
        0 & $x$ & $x$ \\
        \hline
    \end{tabular}
    \\ \vspace{10pt}
    \begin{tabular}{|c|c|c|}
        \hline
        0 & $x$ & $x$ \\
        \hline
        $x$ & 1 & 1 \\
        \hline
        $x$ & 1 & 0 \\
        \hline
    \end{tabular}
    \hspace{20pt}
    \begin{tabular}{|c|c|c|}
        \hline
        $x$ & $x$ & 0 \\
        \hline
        1 & 1 & $x$ \\
        \hline
        0 & 1 & $x$ \\
        \hline
    \end{tabular}
\end{center}
em que $x$ pode assumir qualquer valor, 0 ou 1.

\section{Definição da Trajetória}

Uma vez que a linha de trajetória passou pelo algoritmo de
afinação, é necessário ordenar os pontos e gerar a trajetória para
o robô. O primeiro passo é definir qual será o ponto inicial.

%*** Explicar a necessidade de se definir um ponto inicial ???? ***
O ponto inicial será o ponto que possuir número de vizinhos igual
a 1 e possuir a cor verde (escolhida arbitrariamente). A cor
diferente foi utilizada já que a trajetória desenhada possui duas
extremidades, e o pixel de cada extremidade atende ao critério de
possuir apenas um vizinho.

Definido o ponto inicial, é necessário ordenar todos os outros
pontos para formar a trajetória. Para esta ordenação, é criada uma
matriz de direções [x,y] equivalente à imagem e para cada ponto
pertencente à trajetória é associada a informação referente à sua
conectividade, como mostrado na Figura \ref{fig:MatDir}.

\begin{figure}[htb]
    \center
    % Figura de uma imagem 4x4 (ou outro tamanho que caiba na coluna) mostrando uma trajetória e a matriz de
    \caption{???}
    \label{fig:MatDir}
\end{figure}

%*** Explicar através de texto como a informação da conectividade ? Mostrar estruturas utilizadas ? ***


Após criada a matriz de direções, a partir do ponto inicial da
trajetória,  os pontos são ordenados.

O algoritmo se baseia em percorrer os pontos adjacentes até que
não existam mais pontos para serem percorridos. Caso exista mais
de um ponto adjacente a um mesmo pixel, será escolhido aquele que
cause menor modificação na direção e sentido do caminho percorrido
pelo robô. Caso dois pontos causem a mesma alteração no movimento,
serão verificadas recursivamente as direções dos pontos
anteriores. Caso o empate persista, é escolhido um ponto de acordo
com a ordem N, NE, E, SE, S, SW, W, NW (mesma ordem de numeração
dos pontos no algoritmo de Zhang-Suen).

A Figura \ref{fig:SortExample} mostra ?????

\begin{figure}[htb]
    \center
    % Aplicar o algoritmo à figura anterior em 3 ou 4 passos
    \caption{???}
    \label{fig:SortExample}
\end{figure}

Os pontos escolhidos são armazenados na forma de uma lista
encadeada. Além das coordenadas [x,y], a cor do ponto também é
armazenada para futuramente definir os parâmetros da trajetória
(por exemplo, velocidade de movimentação, parâmetros de soldagem
etc.).

\section{Geração do programa para o robô}
Depois de montada a lista com informações da trajetória e de
parâmetros de utilização, é necessário gerar o programa na
linguagem do robô para executar estas tarefas.

O arquivo é gerado baseando-se em um modelo de acordo com a
linguagem do robô. O objetivo de se utilizar o modelo é permitir
que o usuário possa inserir informações específicas e até
programar alguma tarefa antes da execução da trajetória. A
programação da trajetória é inserida no código em uma posição
definida no modelo.


\section{Resultados}

A metodologia apresentada foi aplicada na geração de um programa
para o manipulador robótico KUKA modelo KR-6 com controlador
KRC-2.

% *** Mostrar exemplo de template ***

Como todas as informações relativas à trajetória são independentes
do modelo de robo escolhido, com poucas alterações pode ser
adaptado para qualquer outro modelo ou fabricante.

\section{Conclusões}

Foi apresentada uma metodologia para geração de trajetórias para
robôs industriais a partir de imagens bidimensionais geradas
artificialmente. O programa se mostrou eficiente, sendo capaz de
tratar inclusive trajetórias que possuam cruzamentos, escolhendo a
direção e sentido de movimento mais apropriados.

Atualmente, encontram-se em desenvolvimento uma metodologia para
definição automática do sistema de coordenadas e escala do desenho
a partir de eixos representados na própria imagem. Além disso,
técnicas de tratamento de imagens estão sendo estudadas para ser
possível a utilização de fotografias no próprio espaço de trabalho
do robô.

\section*{Agradecimentos}

    Os autores agradecem ao PIBIC/CNPq pelo apoio financeiro e à KUKA Roboter pela disponibilização
    do equipamento para realização dos testes.

% BIBLIOGRAFIA
\bibliography{bibliRomulo}

\end{document}
